# 使用方法

## 命令行方式

**bash**: `lsc [options]... [file]...`

###### 常见用法：

```bash
Usage: lsc [option]... [file]...

Use 'lsc' with no options to start REPL.

Misc:
  -v, --version                  display version
  -h, --help                     display this help message
  -c, --compile                  compile to JavaScript and save as .js files
  -e, --eval code::String        pass as string from the command line as input
  -d, --prelude                  automatically import prelude.ls in REPL
  -r, --require paths::[String]  require libraries before executing
  -s, --stdin                    read stdin
  -j, --json                     print/compile as JSON
  -n, --nodejs                   pass options after this through to the 'node' binary
  -w, --watch                    watch scripts for changes, and repeat
  -k, --const                    compile all variables as constants

Output control:
  -o, --output path::String      compile into the specified directory
  -p, --print                    print the result to stdout
  -b, --bare                     compile without the top-level function wrapper
  --no-header                    do not add "Generated by" header
  -l, --lex                      print the tokens the lexer produces
  -t, --tokens                   print the tokens the rewriter produces
  -a, --ast                      print the syntax tree the parser produces
  --debug                        print debug output when compiling
  -m, --map String               generate source maps - either: 'none', 'linked',
                                 'linked-src', 'embedded', or 'debug' - default: none

Version 1.5.0
<http://livescript.net/>
```



## 命令行使用举例

- 通过node.js运行一个LiveScript文件：`lsc file.ls` - 也可省略`.ls`后缀。
- 编译一个LiveScript文件，生成`file.js`：`lsc -c file.ls`。
- 监听一个文件，并在有更改时重新编译：`lc -wc file.ls`。
- 编译一个目录的文件，生成一个新的文件夹：`lsc -co output src`。
- 编译一段LiveScript代码，并打印对应JS代码：`lsc -bpe '[1 to 5]'`。
- 运行LiveScript REPL：`lsc` - `Ctrl-D`退出，`Ctrl-J`进入多行输入模式。



## JSON

如果想将LiveScript格式的JSON代码编译为`.json`文件，可以使用`.json.ls`文件后缀，或者编译时添加参数`-j,--json`。

如果想通过函数式的命令行获取JSON数据，可以对JSON数据使用`-e,-eval`参数。被提供的JSON数据被绑定在这个eval表达式中的`this`上。提供JSON数据可以通过管道语句并使用`-j,--json`参数，或者直接使用`.json`后缀的文件。

```bash
$ lsc -de '@files |> map (.to-upper-case!)' package.json
[
  "LIB",
  "BIN",
  "README.MD",
  "LICENSE"
]
```



可以通过`-d,--prelude`参数引入[prelude.ls](http://www.preludels.com/)。

```shell
$ lsc -de '@files |> map (.to-upper-case!)' package.json
[
  "LIB",
  "BIN",
  "README.MD",
  "LICENSE"
]
```



也可以通过`-r,--require`参数方便地引入模块。

```shell
lsc -r 'path' -de '@files |> map -> [it, path.resolve it]' package.json
[
  [
    "lib",
    "/home/z/open-source/LiveScript/lib"
  ],
  [
    "bin",
    "/home/z/open-source/LiveScript/bin"
  ],
  [
    "README.md",
    "/home/z/open-source/LiveScript/README.md"
  ],
  [
    "LICENSE",
    "/home/z/open-source/LiveScript/LICENSE"
  ]
]
```



## 程式化API：

在Node或Browserify项目中引入：`var LiveScript = require('livescript');`或`require! livescript`，又或者通过前几章提到的浏览器内安装步骤。在Node环境下，通过`require`引入的同时会在在`require.extensions`中注册。



###### 常见用法：

`LiveScript.compile(code :: String, options :: Object?) -> String`

编译一个LiveScript的字符串为JavaScript代码。如果编译失败会抛出错误。

选项：

| 选项                       | 含义                                       |
| ------------------------ | ---------------------------------------- |
| header :: Boolean = true | if true, add the "Generated by" header   |
| const :: Boolean = false | if true, compile all variables as constants |
| filename :: String?      | an optional filename to use for compilation errors |
| bare :: Boolean = false  | if true, compile without the top-level function wrapper |



`LiveScript.run(code :: String, options :: Object?) -> String`

执行一段LiveScript代码的字符串。如果编译失败会抛出一个语法错误。需要注意的是，这个功能使用了`Function`构造函数。

选项：

| 选项                       | 含义                                       |
| ------------------------ | ---------------------------------------- |
| const :: Boolean = false | if true, compile all variables as constants |
| filename :: String?      | an optional filename to use for errors   |



######  更多使用方法：

`LiveScript.ast(code :: String|Array) -> Object`

如果是字符串类型，会生成LiveScript源代码的抽象语法树（AST）；如果是数组类型，会生成记号流（token stream）。若该字符串不能被解析成为LiveScript代码，会抛出语法错误；若是一个数组，当该流（stream）不合法，会抛出一个错误。



`LiveScript.tokens(code :: String, options :: Object?) -> Array`

由LiveScript代码生成记号流（token stream）。需要注意的是，在各个调用间它并不维持状态。

| 选项                     | 含义                                       |
| ---------------------- | ---------------------------------------- |
| raw :: Boolean = false | if true, do not flush the token stream before tokenizing - recommended to leave as default |
| line :: Number = 0     | the starting line number for the token stream |



`LiveScript.lex(code :: String)`等同于`LiveScript.tokens(code, {raw: true})`。



`LiveScript.ast.* :: Object...`

被`LiveScript.ast()`调用的所有AST构造函数。



###### 浏览器环境独有的方法：

`LiveScript.stab(code :: String, callback :: (err :: Error?) -> void, filename :: String?) -> void`

运行一段代码的字符串，并附带一个可选错误类型的回调函数。



`LiveScript.load(url :: String, callback :: (err :: Error?) -> void) -> void`

根据`url`通过`XMLHttpRequest`加载一个远程LiveScript文件，并附带一个可选错误类型的回调函数。



`LiveScript.go() -> void`

利用内容为`"text/ls"`或`"application/ls"`的type属性加载全部脚本。